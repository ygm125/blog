(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(e,t,a){"use strict";a.r(t),t.default=[{title:"Evo 一个类 Vue 的 MVVM 框架",path:"/posts/evo.html",strippedContent:' ### 概述  Vue 一个 MVVM 框架、一个响应式的组件系统，通过把页面抽象成一个个组件来增加复用性、降低复杂性，主要特色就是数据操纵视图变化，一旦数据变化自动更新所有关联组件~  所以它的一大特性就是一个数据响应系统，当然有了数据还需要一个模板解析系统，即 HTMLParse 帮我们把数据模板生成最终的页面，但每次数据变动都重新生成 HTML 片段挂载到 DOM 性能肯定慢的没法说,所以还需要 Virtual DOM 把最少的变动应用到 DOM 上，以提升性能  基本上述三项组装到一起也就出来了我们自己的 Vue 框架 Evo  ### Virtual DOM  下面先说下 Virtual DOM  所谓的 Virtual DOM 就是用 JS 来模拟 DOM 树（因为 JS 操作比 DOM 快很多）  每次数据变动用新生成的树与之前的树做比对，计算出最终的差异补丁到真正的 DOM 树上  Vue 2.0 底层基于 Snabbdom 这个 Virtual DOM 做了优化与整合  具体可以到这里查看 [https://github.com/snabbdom/snabbdom](https://github.com/snabbdom/snabbdom)  这个库的主要特色是简单、模块化方便扩展与出色的性能  简单例子  ```js var snabbdom = require("snabbdom"); var patch = snabbdom.init([   // Init patch function with chosen modules   require("snabbdom/modules/class").default, // makes it easy to toggle classes   require("snabbdom/modules/props").default, // for setting properties on DOM elements   require("snabbdom/modules/style").default, // handles styling on elements with support for animations   require("snabbdom/modules/eventlisteners").default // attaches event listeners ]); var h = require("snabbdom/h").default; // helper function for creating vnodes  var container = document.getElementById("container");  var vnode = h("div#container.two.classes", { on: { click: someFn } }, [   h("span", { style: { fontWeight: "bold" } }, "This is bold"),   " and this is just normal text",   h("a", { props: { href: "/foo" } }, "I\'ll take you places!") ]); // Patch into empty DOM element – this modifies the DOM as a side effect patch(container, vnode);  var newVnode = h(   "div#container.two.classes",   { on: { click: anotherEventHandler } },   [     h(       "span",       { style: { fontWeight: "normal", fontStyle: "italic" } },       "This is now italic type"     ),     " and this is still just normal text",     h("a", { props: { href: "/bar" } }, "I\'ll take you places!")   ] ); // Second `patch` invocation patch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state ```  不难看出 patch 就是一个模块化的功能聚合，你也可以根据核心的 Hook 机制来提供自己的功能模块  然后通过 snabbdom/h 来创建 vnodes，最后用 patch 做更新处理  这个库的代码量不大，实现的非常灵活，有兴趣的可以读读源码，另外也建议读读这篇文章 [深度剖析：如何实现一个 Virtual DOM 算法 #](https://github.com/livoras/blog/issues/13) 以更好的了解内部原理  不过从上面的语法可以看出使用起来相当麻烦，所以我们需要一种简单的书写方式来帮我们解析成对应的语法规则  也就是要说的 HTML Parse  ### HTML Parser  Vue 2.0 的 Parse 原型基于 John Resig 的 HTML Parser，这个 Parser 写的很小巧，可以到这里了解 [http://ejohn.org/blog/pure-javascript-html-parser/](http://ejohn.org/blog/pure-javascript-html-parser/)  基本的 HTML 解析用法  ```js var results = "";  HTMLParser(html, {   start: function(tag, attrs, unary) {     results += "<" + tag;      for (var i = 0; i < attrs.length; i++)       results += " " + attrs[i].name + \'="\' + attrs[i].escaped + \'"\';      results += (unary ? "/" : "") + ">";   },   end: function(tag) {     results += "</" + tag + ">";   },   chars: function(text) {     results += text;   },   comment: function(text) {     results += "\x3c!--" + text + "--\x3e";   } });  return results; ```  可以看出它把 HTML 解析后对应的节点数据都传入了处理函数，Vue 在它的基础上做了升级与优化处理，在拿到对应的节点数据后做一些自己的解析处理，如 分析 v-if、v-for、v-on 等属性做指令处理，也就出来了 Vue 的模板系统~  ### 响应式系统  下面在说下响应系统  数据响应主要是依据 ES5 的 getter 与 setter 来做数据变化的钩子处理，比如下面  ```js Object.defineProperty(obj, key, {   enumerable: true,   configurable: true,   get: () => {     // some handle     return val;   },   set: newVal => {     if (newVal === val) return;     val = newVal;     //some handle   } }); ```  这样取值与赋值的过程中都可以做一些我们自己的处理，比如 set 的时候我们可以判断值是否真的发生了变化，变化了可以触发我们的重新渲染函数，做虚拟 DOM 比对处理更新界面  不过说明下并不是一旦有数据变动我们就要做重新渲染，看这个例子  ```js new Vue({   template: `         <div>           <section>             <span>name:</span> {{name}}           </section>           <section>             <span>age:</span> {{age}}           </section>         <div>`,   data: {     name: "js",     age: 24,     height: 180   } });  setTimeout(function() {   demo.height = 181; }, 3000); ```  可以看到 height 的变动与我们的模板完全无关，如果做重渲染会造成浪费，所以 Vue 做了一个收集依赖  Vue 在第一次渲染的时候会读取需要的数据，所以它在 get 的时候做了手脚（依赖收集），后面只有依赖的数据变动才会触发重渲染  想更详细的了解数据响应的可以看看这个 [vue2.0 源码分析之理解响应式架构](https://segmentfault.com/a/1190000007334535)  不过 ES5 的 setter、getter，使用与处理起来还是有些麻烦与不便  所以数据方面我选择了这个 [https://github.com/nx-js/observer-util](https://github.com/nx-js/observer-util) 使用 Proxy 的库做响应处理（毕竟现在不考虑兼容性~）  实现原理与上面的差不多，只不过更简单，功能更强一些~  ### 总结  上面就是我们主要参考的技能点，让我们加些代码把它们连起来，这样自己的框架就出来了  最终的实现代码在这里 [https://github.com/ygm125/evo](https://github.com/ygm125/evo)  evo = easy + vue + o，快来帮我 star 吧！  下面来个例子，跑起来  ```js <div id="app">     <div :message="message">{{ message }}</div>      <a v-for="(item,index) in list" @click="popMsg(item.text)">{{index}}、{{item.text}}</a>      <my-component :message="message"></my-component>      <div v-if="first">first</div>     <div v-else>not</div> </div> <script src="../dist/evo.js"><\/script> <script>      var Child = {         data: {             text: \'component\'         },         template: \'<div>A custom {{text}} {{message}}!</div>\'     }      var app = new Evo({         components: {             \'my-component\': Child         },         el: "#app",         data: {             first: true,             message: "Hello Evo!",             list: [{                 text: "Im one"             }, {                 text: "Im two"             }]         },         methods: {             popMsg(msg) {                 alert(msg)             }         }     })      setTimeout(function(){         app.message = \'HI\'     },1000)  <\/script> ```  当然实现一个完整的东西还是有很多路要走的，这是一个精雕细琢、不断升华的过程~ '},{title:"React 系列之 Redux",path:"/posts/react-redux.html",strippedContent:' ### 前言  没想到这篇文章这么晚才出，最近发生了太多的事情，已致于心态全无，很多事情只有经历才能感受真实，我们都需要成长  ### 介绍  前面看到 Flux 架构相对来说还是比较繁琐，同时社区也涌现了很多第三方的框架模式，而 Redux 则脱颖而出  React 以组件的形式维护了一颗 UI 树，但是对状态数据没有做更多的处理，Redux 则把状态数据也抽象成了一棵树来维护  它本身与 React 没有直接关系，可以与其他框架配合使用，也可以很好的与 React 配合使用  Redux 的代码量非常短小，核心只提供了 5 个 API  - createStore  - combineReducers  - bindActionCreators  - applyMiddleware  - compose  下面先来直观的感受下 Redux  ```js import { createStore } from "redux";  function counter(state = 0, action) {   switch (action.type) {     case "INCREMENT":       return state + 1;     case "DECREMENT":       return state - 1;     default:       return state;   } }  let store = createStore(counter);  store.subscribe(() => console.log(store.getState()));  store.dispatch({ type: "INCREMENT" }); // 1 store.dispatch({ type: "INCREMENT" }); // 2 store.dispatch({ type: "DECREMENT" }); // 1 ```  表象可以看出入口是 createStore，接收一个函数（这里叫做 reducer），这个函数接收 state 与 action 俩个参数，然后 dispatch 一个对象（这里叫 action ,要包含一个 type 属性标明行为），reducer 函数就会被触发执行来操作状态，同时也会触发 subscribe 订阅的回调，回调可以通过 store.getState() 获取当前状态数据  到这里都很简单，那么如果我们需要处理的数据和状态越来越多 reducer 函数就会越来越大导致难以维护，所以 Redux 提供了 combineReducers 来处理这种情况，它把这个大的 reducer 分解成一个个小的 reducer ，每个小 reducer 维护自己的状态数据，这样就分解出了一个状态树  做下变种  reducers/todos.js  ```js export default function todos(state = [], action) {   switch (action.type) {     case "ADD_TODO":       return state.concat([action.text]);     default:       return state;   } } ```  reducers/counter.js  ```js export default function counter(state = 0, action) {   switch (action.type) {     case "INCREMENT":       return state + 1;     case "DECREMENT":       return state - 1;     default:       return state;   } } ```  reducers/index.js  ```js import { combineReducers } from "redux"; import todos from "./todos"; import counter from "./counter";  export default combineReducers({   todos,   counter }); ```  App.js  ```js import { createStore } from "redux"; import reducer from "./reducers/index";  let store = createStore(reducer); console.log(store.getState()); // { // counter: 0, // todos: [] // }  store.dispatch({   type: "ADD_TODO",   text: "Use Redux" }); console.log(store.getState()); // { // counter: 0, // todos: [ \'Use Redux\' ] // } ```  可以看到我们利用 combineReducers 把 reducer 做了拆分，combineReducers 部分精简源码  ```js export default function combineReducers(reducers) {   var reducerKeys = Object.keys(reducers);   var finalReducers = {};   for (var i = 0; i < reducerKeys.length; i++) {     var key = reducerKeys[i];     if (typeof reducers[key] === "function") {       finalReducers[key] = reducers[key];     }   }   var finalReducerKeys = Object.keys(finalReducers);    return function combination(state = {}, action) {     var hasChanged = false;     var nextState = {};     for (var i = 0; i < finalReducerKeys.length; i++) {       var key = finalReducerKeys[i];       var reducer = finalReducers[key];       var previousStateForKey = state[key];       var nextStateForKey = reducer(previousStateForKey, action);       nextState[key] = nextStateForKey;       hasChanged = hasChanged || nextStateForKey !== previousStateForKey;     }     return hasChanged ? nextState : state;   }; } ```  可以看到就是把对象中的 reducer 全部执行一遍，把上次的状态传入进去，最新的状态返回回来，当然你也可以提供自己的  combineReducers 方法  前面我们注意到 store.dispatch 都是一个纯对象，也就是说我们的触发都是同步的，如何支持异步？  下面我们来引入 Redux 中间件来增强下  ```js import { createStore, applyMiddleware } from "redux"; import thunk from "redux-thunk"; import rootReducer from "./reducers/index";  function increment() {   return {     type: "INCREMENT_COUNTER"   }; }  function incrementAsync() {   return dispatch => {     setTimeout(() => {       dispatch(increment());     }, 1000);   }; }  const store = createStore(rootReducer, applyMiddleware(thunk));  store.dispatch(increment()); // 同步  store.dispatch(incrementAsync()); // 异步 ```  同步方式的触发跟以前是一样的，这里的异步支持就是靠 Redux 的 applyMiddleware 中间件模式与 thunk 中间件做增强支持的  来看下 applyMiddleware 与部分 createStore 源码  ```js export default function applyMiddleware(...middlewares) {   return createStore => (reducer, preloadedState, enhancer) => {     var store = createStore(reducer, preloadedState, enhancer);     var dispatch = store.dispatch;     var chain = [];      var middlewareAPI = {       getState: store.getState,       dispatch: action => dispatch(action)     };     chain = middlewares.map(middleware => middleware(middlewareAPI));     dispatch = compose(...chain)(store.dispatch);      return {       ...store,       dispatch     };   }; } ```  ```js export default function createStore(reducer, preloadedState, enhancer) {   if (typeof preloadedState === "function" && typeof enhancer === "undefined") {     enhancer = preloadedState;     preloadedState = undefined;   }    if (typeof enhancer !== "undefined") {     return enhancer(createStore)(reducer, preloadedState);   }    //...    return {     dispatch,     subscribe,     getState,     replaceReducer,     [$$observable]: observable   }; } ```  createStore 里所谓的增强就是 applyMiddleware 一些中间件  `const store = createStore( rootReducer, applyMiddleware(thunk) )`  与下面写法是等效的  `const store = applyMiddleware(thunk)(createStore)(rootReducer)`  看上面 applyMiddleware 的源码可以知道会先用 createStore 创建原始 store，然后把 getState 与 dispatch 传给中间件，中间件处理完后返回扩展后的 store  看下 thunk 中间件源码  ```js function createThunkMiddleware(extraArgument) {   return ({ dispatch, getState }) => next => action => {     if (typeof action === "function") {       return action(dispatch, getState, extraArgument);     }      return next(action);   }; }  const thunk = createThunkMiddleware(); thunk.withExtraArgument = createThunkMiddleware;  export default thunk; ```  很简单传入 dispatch, getState 后返回 next => action = > {...}，然后传入 store.dispatch 返回 action => {...} 即扩展后的 dispatch  这个新的 dispatch 也是接受 action，如果是对象用原始 store.dispatch 直接触发，如果是函数则把 dispatch 传进函数体，把控制权交给函数内部  注意后面执行用到的 dispatch 已是扩展后的能处理函数的 dispatch  回过头来在说下 compose API，applyMiddleware 可以接受一系列中间件，内部调用 compose 来做处理  `compose(...chain)` 等同于 `(...args) => f(g(h(...args)))`  也就是说传入一组函数，它会倒序执行，把前一个的执行结果传给下一个，达到渐进增强效果  说到这里 Redux 和 它的 API 终于介绍差不多了，至于 bindActionCreators 后面介绍  说了这么多可以看到 Redux 自己就可以跑，那如何与 React 结合起来？那就需要 react-redux 这个中间桥梁了  react-redux 提供了俩个 API  - Provider store  - connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])  Provider 就是一个 React 组件，它接收一个 store 属性，把 store 挂在 React 的 Context 上，这样它的子组件不需要显示的传递 store 就可以获取到  看个例子  ```js import { Provider } from "react-redux";  const store = createStore(reducer);  render(   <Provider store={store}>     <App />   </Provider>,   document.getElementById("root") ); ```  那么问题来了，可以获取到 store 后呢，如何做交互以及 React 与 Redux 的沟通，这时候 connect API 就派上用场了  还是继续看个例子  ```js import { bindActionCreators } from "redux";  const App = ({ todos, actions }) => (   <div>     <Header addTodo={actions.addTodo} />     <MainSection todos={todos} actions={actions} />   </div> );  const mapStateToProps = state => ({   todos: state.todos });  const mapDispatchToProps = dispatch => ({   actions: bindActionCreators(TodoActions, dispatch) });  export default connect(   mapStateToProps,   mapDispatchToProps )(App); ```  connect 的源码执行大概是这样  ```js export default function connect(   mapStateToProps,   mapDispatchToProps,   mergeProps,   options = {} ) {   return function wrapWithConnect(WrappedComponent) {     class Connect extends Component {       constructor(props, context) {         this.store = props.store || context.store;       }        render() {         const mappedState = mapStateToProps(store.getState(), this.props);         const mappedDispatch = mapDispatchToProps(store.dispatch, this.props);          const mergedProps = {           mappedState,           mappedDispatch         };          this.renderedElement = createElement(WrappedComponent, mergedProps);         return this.renderedElement;       }     }   }; } ```  这里做了适当的简化，从这可以看出 connect 返回了一个 Connect 组件获取到 store，然后把 store.getState() 与 store.dispatch  传递给我们的 mapStateToProps 与 mapDispatchToProps 函数，返回相应的数据与方法通过 props 传递给 React 组件，这样 React 组件就可以获取到相应数据展示，同时也可以通过 dispatch 触发 Redux store 的数据变动，Connect 组件在根据数据对比看是否需要重新渲染~  connect 实际的代码比这复杂的多，内部做了细致的浅数据对比以提升性能  对于 react-redux 这里还有一个潜规则，那就是展示组件与容器组件相分离，就是说只有容器组件处理数据与状态与 Redux 沟通，  展示组件只做正常的 UI 渲染，可以从这里了解更多 [https://redux.js.org/basics/usage-with-react](https://redux.js.org/basics/usage-with-react)  再看下上面的  ```js const mapDispatchToProps = dispatch => ({   actions: bindActionCreators(TodoActions, dispatch) }); ```  会把传入的函数或对象的每一个方法做下面的变形  ```js function bindActionCreator(actionCreator, dispatch) {   return (...args) => dispatch(actionCreator(...args)); } ```  这样 React 组件调用对应的 action 时就可以 dispatch 这个 actionCreator 产生的数据  最终不管有没有明白都可以看下 [Redux TodoMVC Example](https://github.com/reduxjs/redux/tree/master/examples/todomvc)  这个例子来加深下理解，以及目录结构的分工，当然有兴趣多了解一些例子就更好了  这篇到这里终于算是写完了，最后大家加油！ '},{title:"React 系列之 Flux",path:"/posts/react-flux.html",strippedContent:' ### 概述  由于 React 只涉及 UI 层的处理，所以构建大型应用应该搭配一个框架模式才能使后期维护成本相对较小~  Flux 正是 FB 官方给出的应用架构，他推崇一种单向的数据流动模式，看下图感受下  ![](https://image-static.segmentfault.com/148/213/1482139906-57c5356ee7a2a_articlex)  整个流程是  - 用户与 View 层交互，触发 Action  - Action 使用 Dispatcher 进行分发  - Dispatcher 触发 Store 回调进行更新  - Store 更新触发 View 层事件  - View 层 收到信号进行更新  相对传统 MV\\* 模式，Flux 一个最大的特色就是单向的数据流让事情变的可预见，看下面大型应用图感受下不同  MV\\*  ![](http://cc.cocimg.com/api/uploads/20150930/1443597860689661.jpg)  Flux  ![](http://cc.cocimg.com/api/uploads/20150930/1443597957408505.jpg)  其实概念说了一堆还是比较难理解，大家可以配合 flux-todomvc 官方示例来直观感受理解下  app.js 渲染的是 TodoApp.react.js 这个组件，组件内部从 TodoStore 获取数据传递给子组件，同时监听了 TodoStore 的数据变化，FB 管这种顶层 View 叫做 Controller-View  TodoApp.react.js  ```js var TodoStore = require("../stores/TodoStore");  function getTodoState() {   return {     allTodos: TodoStore.getAll(),     areAllComplete: TodoStore.areAllComplete()   }; }  var TodoApp = React.createClass({   getInitialState: function() {     // 获取初始数据     return getTodoState();   },    componentDidMount: function() {     // 监听数据变化     TodoStore.addChangeListener(this._onChange);   },    render: function() {     return (       <div>         <Header />         <MainSection           allTodos={this.state.allTodos}           areAllComplete={this.state.areAllComplete}         />         <Footer allTodos={this.state.allTodos} />       </div>     );   },    _onChange: function() {     this.setState(getTodoState());   } }); ```  TodoApp.react.js 又嵌套了几个子组件，这里我们关注下 Header.react.js 这个子组件感受一下整个流程就好了  Header.react.js 的子组件 TodoTextInput.react.js 监听 dom 输入框的各种事件，触发父组件传递给他的 Action 方法  Header.react.js  ```js var TodoTextInput = require("./TodoTextInput.react");  var Header = React.createClass({   render: function() {     return (       <header id="header">         <h1>todos</h1>         <TodoTextInput           id="new-todo"           placeholder="What needs to be done?"           onSave={this._onSave}         />       </header>     );   },   _onSave: function(text) {     if (text.trim()) {       TodoActions.create(text);     }   } }); ```  TodoTextInput.react.js  ```js var TodoTextInput = React.createClass({   getInitialState: function() {     return {       value: this.props.value || ""     };   },    render: function() {     return (       <input         className={this.props.className}         id={this.props.id}         placeholder={this.props.placeholder}         onBlur={this._save}         onChange={this._onChange}         onKeyDown={this._onKeyDown}         value={this.state.value}         autoFocus={true}       />     );   },    _save: function() {     this.props.onSave(this.state.value);     this.setState({       value: ""     });   },    _onChange: function(event) {     this.setState({       value: event.target.value     });   },    _onKeyDown: function(event) {     if (event.keyCode === ENTER_KEY_CODE) {       this._save();     }   } }); ```  Action 执行 Dispatcher 进行行为分发，这里的 Dispatcher 是 FB 实现的一个事情分发系统  TodoActions.js  ```js var TodoActions = { create: function(text) { AppDispatcher.dispatch({ actionType: TodoConstants.TODO_CREATE, text: text }); }, ... } ```  Dispatcher 的分发会触发 Store 中注册的回调，执行对应的行为更新数据，同时触发 Store Change 事件，那么 TodoApp.react.js 中监听的 Store Change 事件就会触发，重新设置组件的 state 数据，致使 View 重新 render  TodoStore.js  ```js AppDispatcher.register(function(action) {   var text;    switch (action.actionType) {     case TodoConstants.TODO_CREATE:       text = action.text.trim();       if (text !== "") {         create(text);         TodoStore.emitChange();       }       break;     default:     // no op   } }); ```  这样就形成了 Flux 架构的单向闭环更新流，但是写起来还是有些繁琐和复杂性，下一节我们来看更简洁和优雅的方式 Redux ~ '},{title:"React 系列之 Immutable",path:"/posts/react-immutable.html",strippedContent:' ### 介绍  什么是 Immutable Data ？ Immutable Data 是指一旦被创建就不可以被改变的数据，通过使用不可变数据可以让我们很方便的去处理数据的状态、变化检测等问题，而且让我们的程序变得更加的可预见  ### 使用  安装 `npm install immutable`  ```js var Immutable = require("immutable"); var map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set("b", 50); map1.get("b"); // 2 map2.get("b"); // 50 ```  大体 API  ```js // 深度转换 JS Object 和 Array 为 Immutable Map 和 List Immutable.fromJS({ a: { b: [10, 20, 30] }, c: 40 });  // Immutable.List 浅转换 const $arr1 = Immutable.List([1, 2, 3]); $arr1.size; // => 3  // 给倒数第一个赋值 const $arr2 = $arr1.set(-1, 0); // => List [ 1, 2, 0 ]  const $arr3 = $arr1.insert(1, 1.5); // => List [ 1, 1.5, 2, 3 ]  const $arr4 = $arr1.clear(); // => List []  const $arr5 = $arr1.get(0); // => 1  // Immutable Map const $map1 = Immutable.fromJS({ a: { b: 1 }, c: 2 }); $map1.size; // => 2  const $map2 = $map1.update("c", () => 3); // => Map { "a": Map { "b": 1 }, "c": 3 }  const $map3 = $map1.updateIn("a.b", () => 3); // => Map { "a": Map { "b": 3 }, "c": 2 }  const $map4 = $map1.merge({ d: 4 }); // => Map { "a": Map { "b": 1 }, "c": 2, "d": 4 } ```  更多可以查看 [immutable-js](https://immutable-js.github.io/immutable-js/)  为什么要用 Immutable 其实从上面的简单例子可以看出来对原数据的操作我们重新生成一个新的而不影响原来的就好了  JQ 有提供 \\$.extend 可以实现浅拷贝与深拷贝，另外 ES6 也提供原生的方法 Object. assign (浅拷贝)，但其实我们大多数情况我们的数据都很复杂，浅拷贝满足不了，然而对于深拷贝 Immutable 的性能很高  这是因为一般深拷贝都是把所以节点全都复制一遍，而 Immutable 使用结构共享，及对象树中的一个节点变化则只会修改这个节点和受她影响的父节点，其他节进行共享，可以看下下面这个图感受下  ![](https://image-static.segmentfault.com/403/933/4039331718-56cc22613b287_articlex)  配合 React 使用 来看一下上一章留下的问题  ```js import React from "react"; import PureRenderMixin from "react-addons-pure-render-mixin"; import { Map } from "immutable";  var Test = React.createClass({   mixins: [PureRenderMixin],   getInitialState: function() {     return { value: { foo: "bar" } };   },   onClick: function() {     this.setState({       value: { foo: "bar" }     });   },   render: function() {     console.log("re-render");     return <a onClick={this.onClick}>click</a>;   } }); ```  由于对比的是俩个引用不同的对象，所以每次都会触发 re-render，使用 Immutable 后  ```js var Test = React.createClass({   mixins: [PureRenderMixin],   getInitialState: function() {     return { value: Map({ foo: "bar" }) };   },   onClick: function() {     this.setState(({ value }) => ({       value: value.set("foo", "bar")     }));   },   render: function() {     console.log("re-render");     return <a onClick={this.onClick}>click</a>;   } }); ```  值相同时 Immutable 会返回同一个引用，所以比对后，不会触发 re-render  对于父组件  ```js React.createClass({   getInitialState: function() {     return { value: { foo: "bar" } };   },    onClick: function() {     var value = this.state.value;     value.foo += "bar"; // ANTI-PATTERN!     this.setState({ value: value });   },    render: function() {     return (       <div>         <InnerComponent value={this.state.value} />         <a onClick={this.onClick}>Click me</a>       </div>     );   } }); ```  改造后  ```js var Test = React.createClass({   getInitialState: function() {     return { value: Map({ foo: "bar" }) };   },   onClick: function() {     this.setState(({ value }) => ({       value: value.update("foo", v => v + "bar")     }));   },   render: function() {     return (       <div>         <InnerComponent value={this.state.value} />         <a onClick={this.onClick}>Click me</a>       </div>     );   } }); ```  可以预见的是组件一定会更新，因为每次 Immutable Data 更改都会返回一个新对象，而不影响原来对象~ '},{title:"React 系列之 React",path:"/posts/react-react.html",strippedContent:' ### 概述  React 是一个 JS 库，主要是通过操作数据的方式去操纵 DOM，为什么要重造轮子呢，因为 FB 觉的目前市面上的 MV\\* 框架对于创建大型应用程序不够直观，不能满足需求，所以诞生了 React。  React 现在官方的介绍是 Declarative、Component-Based、Learn Once, Write Anywhere，其实开始推出时主要的特色是 Virtual DOM，因为 DOM 操作总是很慢的，而 JS 的性能日趋向上，所以 React 内部用 JS 维护一颗 DOM 树，每次数据变了从新生成一颗树与之前的做对比，把实际变化的地方应用到真实的 DOM 上。其实说它性能高，只不过是用 JS 的方式计算出最小的 DOM 操作，所以性能就上来了。  ### 演练  说到这里我们实际操作下吧，这里假设你熟悉 node、babel、webpack 方式，当然你也可以选择你喜好的方式 [传送门](https://reactjs.org/docs/getting-started.html)  首先创建目录结构  ``` react-demo     .babelrc     index.html     src         app.js ```  index.html  ```html <!DOCTYPE html> <html lang="en">   <head>     <meta charset="utf-8" />     <meta name="viewport" content="width=device-width, initial-scale=1" />     <title>React App</title>   </head>   <body>     <div id="app"></div>     <script src="bundle.js"><\/script>   </body> </html> ```  app.js  ```js var React = require("react"); var ReactDOM = require("react-dom");  var HelloMessage = React.createClass({   render: function() {     return <div>Hello {this.props.name}</div>;   } });  ReactDOM.render(<HelloMessage name="John" />, document.getElementById("app")); ```  .babelrc  ```js { "presets": ["es2015","react"] } ```  安装依赖  `npm install --save react react-dom babel-preset-react babel-loader babel-core`  编译监听  `webpack src/app.js bundle.js -w --module-bind \'js=babel\'`  打开 index.html 查看效果  先说下 jsx 语法，React 让你不需要再写 html 拼接字符等操作，而是直接写 html，js 处理放到 { } 里书写，官方提供 jsx 语法非必要，也可以脱离写纯 js 的，如上面的经过编译后  ```js "use strict";  var HelloMessage = React.createClass({   displayName: "HelloMessage",    render: function render() {     return React.createElement("div", null, "Hello ", this.props.name);   } });  ReactDOM.render(   React.createElement(HelloMessage, { name: "John" }),   document.getElementById("app") ); ```  但是可以看出这么麻烦没人去手写的  再来说下组件，React 的概念就是给应用分层，创建一个个组件，最后拼出一个页面，组件方便后期的维护、扩展、以及再重用，随着组件的越多后面写的代码越少，来个例子  ```js var Avatar = React.createClass({   render: function() {     return (       <div>         <PagePic pagename={this.props.pagename} />         <PageLink pagename={this.props.pagename} />       </div>     );   } });  var PagePic = React.createClass({   render: function() {     return (       <img         src={"https://graph.facebook.com/" + this.props.pagename + "/picture"}       />     );   } });  var PageLink = React.createClass({   render: function() {     return (       <a href={"https://www.facebook.com/" + this.props.pagename}>         {this.props.pagename}       </a>     );   } });  ReactDOM.render(   <Avatar pagename="Engineering" />,   document.getElementById("app") ); ```  可以看到组件要提供自己的 render 方法，组件可以相互嵌套，数据通过 this.props 单向传递  同时需要注意，属性 class 要写成 className，for 写成 htmlFor，因为它们是 js 的保留字  对于 render 返回的内容只能有一个顶级标签，如果标签超过多行要用 ( ) 包含  关于 props 不要去改变它，会导致一些不可预知的问题，另外官方推荐用 es6 的 ... 操作符去挂载属性  ```js var props = { foo: "default", bar: "bar" }; var component = <Component {...props} foo={"override"} />; console.log(component.props.bar); // \'bar\' console.log(component.props.foo); // \'override\' ```  这里有个特殊属性 this.props.children，来个例子  ```js var NotesList = React.createClass({   propTypes: {     children: React.PropTypes.array.isRequired   },   render: function() {     return (       <ol>         {React.Children.map(this.props.children, function(child) {           return <li>{child}</li>;         })}       </ol>     );   } });  ReactDOM.render(   <NotesList>     <span>hello</span>     <span>world</span>   </NotesList>,   document.getElementById("app") ); ```  同时可以看到这里提供了 propTypes 可以给属性做检查，验证说明 children 必须提供且是一个数组(多个)，更多的类型验证可以 看这里  前面创建组件都是通过 React.createClass ，可以通过 es6 class 语法  ```js class HelloMessage extends React.Component {   render() {     return <div>Hello {this.props.name}</div>;   } } ReactDOM.render(   <HelloMessage name="Sebastian" />,   document.getElementById("app") ); ```  还有 Stateless Functions 方式  ```js function HelloMessage(props) {   return <div>Hello {props.name}</div>; } ReactDOM.render(   <HelloMessage name="Sebastian" />,   document.getElementById("app") ); ```  官方推荐尽量写 stateless functions ，因为未来会优化这些来避免无用的检查和内存分配  下面看下如何写事件  ```js var Input = React.createClass({   getInitialState: function() {     return { value: "Hello!" };   },   handleChange: function(event) {     this.setState({ value: event.target.value });   },   render: function() {     var value = this.state.value;     return (       <div>         <input type="text" value={value} onChange={this.handleChange} />         <p>{value}</p>       </div>     );   } });  ReactDOM.render(<Input />, document.getElementById("app")); ```  骆驼式的 on 语法即可监听事件，事件是标准的跨浏览器的事件，虽然内联写法，但是是委托实现的~  说到了事件交互可能就要设及获取真实的 dom 节点，React 通过 ref 设置，来个例子  ```js var React = require("react"); var ReactDOM = require("react-dom");  var MyComponent = React.createClass({   handleClick: function() {     this.refs["myinput"].focus();   },   render: function() {     return (       <div>         <input type="text" ref="myinput" />         <input           type="button"           value="Focus the text input"           onClick={this.handleClick}         />       </div>     );   } });  ReactDOM.render(<MyComponent />, document.getElementById("app")); ```  ref 字符属性的方式未来会被废弃，官方推荐使用 ref callback 方式  ```js var MyComponent = React.createClass({   handleClick: function() {     if (this.myTextInput !== null) {       this.myTextInput.focus();     }   },   render: function() {     return (       <div>         <input type="text" ref={ref => (this.myTextInput = ref)} />         <input           type="button"           value="Focus the text input"           onClick={this.handleClick}         />       </div>     );   } });  ReactDOM.render(<MyComponent />, document.getElementById("app")); ```  说到这里看下组件的生命周期与如何更新，还是来个例子  ```js var Timer = React.createClass({   getInitialState: function() {     return { secondsElapsed: 0 };   },   tick: function() {     this.setState({ secondsElapsed: this.state.secondsElapsed + 1 });   },   componentDidMount: function() {     this.interval = setInterval(this.tick, 1000);   },   componentWillUnmount: function() {     clearInterval(this.interval);   },   render: function() {     return <div>Seconds Elapsed: {this.state.secondsElapsed}</div>;   } });  ReactDOM.render(<Timer />, document.getElementById("app")); ```  生命周期有三个主要部分  Mounting 插入 dom  - getInitialState()  - componentWillMount()  - componentDidMount ()  Updating 重新渲染  - componentWillReceiveProps(object nextProps)  - shouldComponentUpdate(object nextProps, object nextState)  - componentWillUpdate(object nextProps, object nextState)  - componentDidUpdate(object prevProps, object prevState)  Unmounting 移除 dom  - componentWillUnmount()  周期提供了 will 方法在事情发生之前调用， did 方法在事情法神之后调用，具体查看这里  对于更新，上面的例子在组件 componentDidMount (插入 dom 后) hook 中定时更新组件的 state，state 变更会导致 render 重新渲染页面  对于这里说下性能问题，虽然虚拟 dom 计算过程很快，但是很多时候我们可以避免它的计算以更好的优化处理  例如：一个组件的更新可能会导致它的子组件一起跟着更新，子组件很可能没有变化，但同样会进行一次 diff 运算，白白浪费了时间，所以 React 提供了 shouldComponentUpdate 钩子函数，默认是直接返回 true，也及是每次都运算比较，所以我们可以在这里优化，来个例子  ```js React.createClass({   propTypes: {     value: React.PropTypes.string.isRequired   },   shouldComponentUpdate: function(nextProps, nextState) {     return this.props.value !== nextProps.value;   },   render: function() {     return <div>{this.props.value}</div>;   } }); ```  这里只有 value 变化的时候在重新渲染计算，否则直接跳过  对于上面的浅对比，React 提供了通用解决方案 PureRenderMixin 扩展，应用 React 的 mixins 功能即可自动实现处理比对  ```js var PureRenderMixin = require("react-addons-pure-render-mixin"); React.createClass({   mixins: [PureRenderMixin],    render: function() {     return <div>{this.props.value}</div>;   } }); ```  但是如果有深层结构，上面的处理可能不会按预期工作，例如  ``` // this.props.value 的值为 { foo: \'bar\' } // nextProps.value 的值为 { foo: \'bar\' } // 但是对象的引用不同，导致不会相等 this.props.value !== nextProps.value; // true ```  而且如果我们不小心管理引用的话也会引发另一些问题，例如这个组件有一个父组件  ```js React.createClass({   getInitialState: function() {     return { value: { foo: "bar" } };   },    onClick: function() {     var value = this.state.value;     value.foo += "bar"; // ANTI-PATTERN!     this.setState({ value: value });   },    render: function() {     return (       <div>         <InnerComponent value={this.state.value} />         <a onClick={this.onClick}>Click me</a>       </div>     );   } }); ```  首先内部组件得到 { foo: \'bar\' }，点击后出发 value 更新 { foo: \'barbar\' },触发 re-rendering 程序，内部组件将会得到 { foo: \'barbar\' }，但是 this.props.value 与 nextProps.value 指向同一个引用，导致任何时候比对都是 true，而导致页面不更新  而且如果父组件应用 PureRenderMixin 的话，由于改动相同引用所以也会导致父组件的 re-rendering 不触发  那最后该如何处理呢？请看下一篇 Immutable-js 来解救你~ '}]}}]);